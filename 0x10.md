```
Author: Antony_Weng <Antony_Weng@chicony.com> | <weng851107@gmail.com>

This file is only used for the record of the learning process, only used by myself and the file has never been leaked out.
If there is related infringement or violation of related regulations, please contact me and the related files will be deleted immediately. Thank you!
```

# 目錄

- [(1) 用#defince定義一年的秒數](#1)
- [(2) 用macro寫函數來比大小](#2)
- [(3) #error指令的目的](#3)
- [(4) 無窮迴圈](#4)
- [(5) 資料宣告](#5)
- [(6) Static的用法](#6)
- [(7) Const的用法](#7)
- [(8) Volatile的用法](#8)
- [(9) Bit操作](#9)
- [(10) 存取固定的記憶體位置](#10)
- [(11) 中斷](#11)
- [(12) 整型提升的問題](#12)
- [(13) 0的一補數](#13)
- [(14) 動態記憶體配置](#14)
- [(15) Typedef](#15)
- [(16) a++的問題](#16)


<h1 id="1">(1) 用#define定義一年的秒數</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-1-%E7%94%A8-defince%E5%AE%9A%E7%BE%A9%E4%B8%80%E5%B9%B4%E7%9A%84%E7%A7%92%E6%95%B8-d147574d6782)

## 原文翻譯

1. *Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer.*

> 使用#define敘述，你會如何如何宣告一個明顯的常數來回傳一年的秒數數量? 在你的答案中忽略閏年

```C
#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)
```

- 測試以下項目：

(a) Basic knowledge of the #define syntax (i.e. no semi-colon at the end, the need to parenthesize etc.).
> 對於#define語法的基礎知識(例如: 不需要在尾端加分號，對括號的需求等)

(b) A good choice of name, with capitalization and underscores.
> 好的名子的選擇，有大寫以及底線

(c) An understanding that the pre-processor will evaluate constant expressions for you. Thus, it is clearer, and penalty free to spell out how you are calculating the number of seconds in a year, rather than actually doing the calculation yourself.
> 了解到預處理會去計算常數運算式。所以簡潔、無懲罰的拼出你是如何計算一年的秒數的數量，而不是真正的由你自己計算

(d) A realization that the expression will overflow an integer argument on a 16 bit machine — hence the need for the L, telling the compiler to treat the expression as a Long.
> 理解到運算式可能會在一個16 bit的機器上對整數產生溢位，因此需要L，告訴編譯器對待運算式為Long

(e) As a bonus, if you modified the expression with a UL (indicating unsigned long), then you are off to a great start because you are showing that you are mindful of the perils of signed and unsigned types — and remember, first impressions count!
> 當一個bonus，如果你更改運算式為UL(意指unsigned long)，你會有一個好的開始，因為你注意到了signd與unsigned型態的危險，並且記住，第一印象很重要


## 自我實作以及理解

```C
#include <stdio.h>

#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)

int main()
{
    printf("%lu\n", SECONDS_PER_YEAR);
    return 0;
}

/****************************
31536000
****************************/
```

<h1 id="2">(2) 用macro寫函數來比大小</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-2-%E7%94%A8macro%E5%AF%AB%E5%87%BD%E6%95%B8%E4%BE%86%E6%AF%94%E5%A4%A7%E5%B0%8F-7d5683b6edd4)

## 原文翻譯

2. *Write the ‘standard’ MIN macro. That is, a macro that takes two arguments and returns the smaller of the two arguments.*

> 寫一個"標準的" MIN macro。也就是說，一個macro接收兩個參數並且回傳這兩個參數中較小的那個

```C
#define MIN(A,B) ((A) <= (B) ? (A) : (B))
```

- 測試以下項目：

(a) Basic knowledge of the #define directive as used in macros. This is important, because until the inline operator becomes part of standard C, macros are the only portable way of generating inline code. Inline code is often necessary in embedded systems in order to achieve the required performance level.
> 對#defince指令用在macros中的基礎知識。這很重要，因為直到inline operator變成standard C的一部分之前，macros是唯一的可攜式的方式來產生inline code。Inline code在嵌入式系統通常是必要的，為了要達到要求的性能水平

(b) Knowledge of the ternary conditional operator. This exists in C because it allows the compiler to potentially produce more optimal code than an if-then-else sequence. Given that performance is normally an issue in embedded systems, knowledge and use of this construct is important.
> 三元運算子的知識。這個在C語言中的存在因為它允許編譯器有潛力的製作比if-then-eles更佳的程式。鑒於性能是一個在嵌入式系統很平常的問題，這方面的知識以及使用這個構造是重要的。

(c) Understanding of the need to very carefully parenthesize arguments to macros.
> 理解需要非常小心的加括號在macros

(d) I also use this question to start a discussion on the side effects of macros, e.g. what happens when you write code such as : `least = MIN(*p++, b);`
> 我也會使用這個問題來開始一個討論在macros的副作用
例: 當你寫程式像這樣會發生什麼? `least = MIN(*p++, b);`

## 自我實作以及理解

- `MIN(A,B) ((A) <= (B) ? (A) : (B))`

    ```C
    #include <stdio.h>

    #define MIN(A,B) ((A) <= (B) ? (A) : (B))

    int main()
    {
        printf("%d\n", MIN(3, 7));
    }

    /********************************
    3
    ********************************/
    ```

- `MIN(A,B) (A) <= (B) ? (A) : (B)`

    ```C
    #include <stdio.h>

    #define MIN(A,B) (A) <= (B) ? (A) : (B)

    int main()
    {
        printf("%d\n", MIN(3, 7));
    }

    /********************************
    3
    ********************************/
    ```

- `MIN(A,B) A <= B ? A : B`

    ```C
    #include <stdio.h>

    #define MIN(A,B) A <= B ? A : B

    int main()
    {
        printf("%d\n", MIN(3, 7));
    }

    /********************************
    3
    ********************************/
    ```

- least = MIN(*p++, b);

```C
#include <stdio.h>

#define MIN(A,B) ((A) <= (B) ? (A) : (B))

int main()
{
    int a[3] = {3, 4, 5};
    int *p = a;
    printf("least value: %d\n", MIN(*p++, 7));
    printf("current pos value of array: %d\n", *p);
    return 0;
}

/**************************************
least value: 4
current pos value of array: 5
**************************************/
```

<h1 id="3">(3) #error指令的目的</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-3-error%E6%8C%87%E4%BB%A4%E7%9A%84%E7%9B%AE%E7%9A%84-38fa98080ab4)

## 原文翻譯

3. *What is the purpose of the preprocessor directive #error?*

> 預處理指令#error的目的是什麼?

- 測試以下項目：

Either you know the answer to this, or you don’t. If you don’t, then see reference 1. This question is very useful for differentiating between normal folks and the nerds. It’s only the nerds that actually read the appendices of C textbooks that find out about such things. Of course, if you aren’t looking for a nerd, the candidate better hope she doesn’t know the answer.
> 你可能會知道或不知道如何回答這題。如果不知道，可以看reference 1。這提是非常有用的來區分normal folks與nerds。只有nerds會實際的去讀C教科書的附錄並且找到相關的東西。當然，如果你不想找到nerds，面試者最好希望自己不知道這題的答案。

  - 原文附的reference 1：`In Praise of the #error directive. ESP September 1999.`

## 自我實作以及理解

[C語言#error預處理](https://www.itread01.com/content/1541838451.html)

- 基本上就這篇文章所說，#error就是生成編譯錯誤的訊息，然後會停止編譯，可以用在檢查程式是否是照自己所預想的執行

  - 例如說我們可以可以我們可以在程式碼加些#ifndef，如果偵測到沒有被define，我們就可以出現使用#error訊息中止程式
  - 這裡我在沒#define NUM1的情況下，使用了#ifndef NUM1，然後就印出#error訊息: No defined NUM1

    ```C
    #include <stdio.h>

    int main()
    {
    #ifndef NUM1
        #error No defined NUM1
    #endif 
        printf("%d\n", NUM1);
        return 0;
    }

    /*****************************************
    Embedded_system_0x10_issues_0x03_1.c: In function ‘main’:
    Embedded_system_0x10_issues_0x03_1.c:6:6: error: #error No defined NUM1
        6 |     #error No defined NUM1
        |      ^~~~~
    Embedded_system_0x10_issues_0x03_1.c:8:20: error: ‘NUM1’ undeclared (first use in this function)
        8 |     printf("%d\n", NUM1);
        |                    ^~~~
    Embedded_system_0x10_issues_0x03_1.c:8:20: note: each undeclared identifier is reported only once for each function it appears in
    *****************************************/
    ```

    ```C
    #include <stdio.h>

    #define NUM1 5

    int main()
    {
    #ifndef NUM1
        #error No defined NUM1
    #endif 
        printf("%d\n", NUM1);
        return 0;
    }

    /****************************************
    5
    Note: 當我們有定義NUM1的話，編譯就會過，不會出現#error所要印出的訊息
    ****************************************/
    ```

<h1 id="4">(4) 無窮迴圈</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-4-%E7%84%A1%E7%AA%AE%E8%BF%B4%E5%9C%88-47a498122c55)

## 原文翻譯

4. *Infinite loops often arise in embedded systems. How does one code an infinite loop in C?*

> 無窮迴圈常出現在嵌入式系統。如何用C寫一行無窮迴圈的程式

- 較好的方式：

    ```C
    while(1)
    {
    …
    }
    ```

- Another：

    ```
    for(;;)
    {
    …
    }
    ```

Personally, I dislike this construct because the syntax doesn’t exactly spell out what is going on. Thus, if a candidate gives this as a solution, I’ll use it as an opportunity to explore their rationale for doing so. If their answer is basically — ‘I was taught to do it this way and I have never thought about it since’ — then it tells me something (bad) about them. Conversely, if they state that it’s the K&R preferred method and the only way to get an infinite loop passed Lint, then they score bonus points.
> 本身來講，我不喜歡這種結構因為這個語法沒有精確的拼出發生什麼事。因此，如果一個被面試的人給出這個解法，我會使用這個當成一個機會來探索用這個合理的原因。如果他們的答案基本上是 — ‘我被教使用這種方法，而且之前我從來沒有想過關於它’ — 然後告訴我一些關於它們事情(不好的)。相反的，如果他們描述說這是K&R喜歡用的方式，並且是為一個方法來達成無窮迴圈且通過Lint，那他們會獲得bonus points。

- The other：

    ```
    Loop:
    …
    goto Loop;
    ```

Candidates that propose this are either assembly language programmers (which is probably good), or else they are closet BASIC / FORTRAN programmers looking to get into a new field.
> 被面試者提出這個，這代表他或許是一個組合語言的程式設計師(這也許是好事)，又或者他們是想進入新領域的BASIC/FORTRAN程式設計師

<h1 id="5">(5) 資料宣告</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-5-%E8%B3%87%E6%96%99%E5%AE%A3%E5%91%8A-81f7b6faabf3)

## 原文翻譯

5. *Using the variable a, write down definitions for the following:*

> 使用變數a，寫下下列的定義：

(a) An integer
> 一個整數

```C
int a; // An integer
```

(b) A pointer to an integer
> 一個指向整數的指標

```C
int *a; // A pointer to an integer
```

(c) A pointer to a pointer to an integer
> 一個指向指標的指標，它指向的指標是指向一個整型數

```C
int **a; // A pointer to a pointer to an integer
```

(d) An array of ten integers
> 一個有10個整數型的陣列

```C
int a[10]; // An array of 10 integers
```

(e) An array of ten pointers to integers
> 一個有10個指標的陣列，該指標是指向一個整數型的

```C
int *a[10]; // An array of 10 pointers to integers
```

(f) A pointer to an array of ten integers
> 一個指向有10個整數型陣列的指標

```C
int (*a)[10]; // A pointer to an array of 10 integers
```

(g) A pointer to a function that takes an integer as an argument and returns an integer
> 一個指向函數的指標，該函數有一個整數型參數並返回一個整數

```C
int (*a)(int); // A pointer to a function a \
that takes an integer argument and returns an integer
```

(h) An array of ten pointers to functions that take an integer argument and return an integer.
> 一個有10個指標的陣列，該指標指向一個函數，該函數有一個整數型參數並返回一個整數

```C
int (*a[10])(int); // An array of 10 pointers to functions \
that take an integer argument and return an integer
```

People often claim that a couple of these are the sorts of thing that one looks up in textbooks — and I agree. While writing this article, I consulted textbooks to ensure the syntax was correct. However, I expect to be asked this question (or something close to it) when in an interview situation. Consequently, I make sure I know the answers — at least for the few hours of the interview. Candidates that don’t know the answers (or at least most of them) are simply unprepared for the interview. If they can’t be prepared for the interview, what will they be prepared for?
> 人們常會說這些是要看教科書的東西 — 我同意。當寫這篇文章的時候，我查了教科書來確認語法是正確的。然後，我期待被問這題(或者是相近的東西)當一場面試發生的時候。因為，我要確認我知道這些答案 — 至少是在幾小時內的面試。不知道這些答案(或者是至少大部分的答案)的應試者是簡明的沒有為這次面試做準備。如果他們沒有準備這場面試，那他們又有什麼能準備的?

## 自我實作以及理解

1. `int *a[10]; // 一個有10個指標的陣列，該指標是指向一個整數型的` 

    宣告了一個int *a[3]，然後另外宣告了三個變數，b = 20，c = 40，d = 60，接著我們讓a[0]的指標指向b，a[1]的指標指向c，a[2]的指標指向d，最後我們再打印輸出看結果

    ```C
    #include <stdio.h>

    int main()
    {
        int *a[3];
        int b = 20, c = 40, d = 60;
        
        a[0] = &b;
        a[1] = &c;
        a[2] = &d;

        printf("*a[0]: %d\n", *a[0]);
        printf("*a[1]: %d\n", *a[1]);
        printf("*a[2]: %d\n", *a[2]);

        return 0;
    }

    /*************************************
    *a[0]: 20
    *a[1]: 40
    *a[2]: 60
    *************************************/
    ```

    接著我們嘗試對每一個指標的數值+1，看看b, c, d的數值是否有隨之改變

    ```C
    #include <stdio.h>

    int main()
    {
        int *a[3];
        int b = 20, c = 40, d = 60;
        
        a[0] = &b;
        a[1] = &c;
        a[2] = &d;

        printf("*a[0]: %d\n", *a[0]);
        printf("*a[1]: %d\n", *a[1]);
        printf("*a[2]: %d\n", *a[2]);
        
        (*a[0])++;
        (*a[1])++;
        (*a[2])++;

        printf("*a[0]: %d and b is %d\n", *a[0], b);
        printf("*a[1]: %d and c is %d\n", *a[1], c);
        printf("*a[2]: %d and d is %d\n", *a[2], d);
        

        return 0;
    }

    /*****************************************
    *a[0]: 20
    *a[1]: 40
    *a[2]: 60
    *a[0]: 21 and b is 21
    *a[1]: 41 and c is 41
    *a[2]: 61 and d is 61
    *****************************************/
    ```

    看起來確實指標與變數之間的數值是聯動的，指標確實指到變數

2. `int (*a)[10]; // 一個指向有10個整數型陣列的指標`

    這裡我們簡化(*a)[10]為(*a)[3]，然後讓它指到一個二維陣列b[2][3]={{1,2,3},{4,5,6}};，並且讓a指到b

    ```C
    #include <stdio.h>

    int main()
    {
        int (*a)[3];
        int b[2][3]={{1,2,3},{4,5,6}};

        a = b;

        printf("%d\n", *(*a));
        printf("%d\n", *(*a+1));
        printf("%d\n", *(*a+2));
        
        
        printf("%d\n", *(*(a+1)));
        printf("%d\n", *(*(a+1)+1));
        printf("%d\n", *(*(a+1)+2));
        return 0;
    }

    /**************************************
    1
    2
    3
    4
    5
    6
    **************************************/
    ```

3. `int (*a)(int); // 一個指向函數的指標，該函數有一個整數型參數並返回一個整數`

    這裡我們先宣告了一個 int func(int num) 的函數，並讓這個函數返回所接收的參數，接著在主函數中，我們宣告 int (*a)(int) 並指到 int func(int num)，接著再直接調用 a(10)，來看輸出結果

    ```C
    #include <stdio.h>

    int func(int num) {
        return num;
    };

    int main(int argc, char* argv[])
    {
        int (*a)(int) = func;
        printf("%d\n", a(10)); // use function pointer
        
        return 0;
    }

    /*****************************************
    10
    *****************************************/
    ```

4. `int (*a[10])(int); // 一個有10個指標的陣列，該指標指向一個函數，該函數有一個整數型參數並返回一個整數`

    其實這個就是function pointer array，這裡我簡化 int (*a[10])(int) 為 int (*a[3])(int)

    這裡我們宣告了一個 int b(int num)，回傳2\*num，宣告了一個 int c(int num)，回傳3\*num，宣告了一個 int d(int num)，回傳4\*num，並讓a[0]指向 b，a[1] 指向 c，a[2] 指向 d，最終把三者都打印出來

    ```C
    #include <stdio.h>

    int b(int num)
    {
        return 2*num;
    }

    int c(int num)
    {
        return 3*num;
    }

    int d(int num)
    {
        return 4*num;
    }

    int main(int argc, char* argv[])
    {
        int (*a[3])(int);
        
        a[0] = b;
        a[1] = c;
        a[2] = d;
        
        printf("%d\n", a[0](1));
        printf("%d\n", a[1](1));
        printf("%d\n", a[2](1));

        return 0;
    }

    /*****************************************
    2
    3
    4
    *****************************************/
    ```

    也可以把function pointer array用(*a[0])(1)這樣的型式調用

    ```C
    #include <stdio.h>

    int b(int num)
    {
        return 2*num;
    }

    int c(int num)
    {
        return 3*num;
    }

    int d(int num)
    {
        return 4*num;
    }

    int main(int argc, char* argv[])
    {
        int (*a[3])(int);
        
        a[0] = b;
        a[1] = c;
        a[2] = d;
        
        printf("%d\n", (*a[0])(1));
        printf("%d\n", (*a[1])(1));
        printf("%d\n", (*a[2])(1));

        return 0;
    }

    /**********************************
    2
    3
    4
    **********************************/
    ```

<h1 id="6">(6) Static的用法</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-6-static%E7%9A%84%E7%94%A8%E6%B3%95-d391dacb28a3)

## 原文翻譯

6. *What are the uses of the keyword static?*

> Static keyword的用法是什麼?

- 測試以下項目：

This simple question is rarely answered completely. Static has three distinct uses in C:
> 這個簡單的問題很少可以被回答的完整。Static有三種不同的用法

1. A variable declared static within the body of a function maintains its value between function invocations.
> 在函數裡面的被宣告為static的變數會在函數呼叫之間維持它的數值

2. A variable declared static within a module [1], (but outside the body of a function) is accessible by all functions within that module. It is not accessible by functions within any other module. That is, it is a localized global.
> 一個變數在一個module內被宣告為static，(但是在函數的body之外)是可以被在同一個module內的所有的函數存取的。在其他module中的函數不能存取。也就是說，這是個區域變數。

3. Functions declared static within a module may only be called by other functions within that module. That is, the scope of the function is localized to the module within which it is declared.
> 在一個module內宣告為static的函數只可以被其他同一個module內的其他函數呼叫。也就是說，這個函數的範圍對它所宣告在的module而言是區域性的。

Most candidates get the first part correct. A reasonable number get the second part correct, while a pitiful number understand answer (c). This is a serious weakness in a candidate, since they obviously do not understand the importance and benefits of localizing the scope of both data and code.
> 大部分的應試者都會做對第一個部分。部分會做對第二部分。只有很少人會做對答案(c)。這是對應試者來說很嚴重的弱點，因為他們很明顯的不了解資料與程式碼區域範圍的重要性以及益處。

## 自我實作以及理解

1. 在修飾變數的時候，static 修飾的靜態區域變數只執行初始化一次，而且延長了區域變數的生命週期，直到程式運行結束以後才釋放。

    這裡我們宣告了一個函數 func() 函數，在這個函數中，我們用static宣告了一個int a為0，並在下一行+1，我們呼叫了這個函數兩次，由於我們是使用static 宣告，最後的輸出結果會是2

    ```C
    #include <stdio.h>

    int func();

    int main()
    {
        func();
        func();
        
        return 0;
    }

    int func()
    {
        static int a = 0;
        a++;
        printf("%d\n", a);
    }

    /************************************
    1
    2
    ************************************/
    ```

2. static 修飾全域變數的時候，這個全域變數只能在本檔中訪問，不能在其它檔中訪問，即便是 extern 外部聲明也不可以。

    首先我們先使用一個檔案宣告變數 num

    ```C
    int num = 20;
    ```

    另外我們再創立另外一個檔案將這個變數印出來

    ```C
    #include <stdio.h>
    
    int main()
    {
        extern int num;
        printf("%d\n", num);
        
        return 0;
    }

    /**************************
    20
    **************************/
    ```

    將 int num = 20 前面加上 keyword static，變成 static int num = 20

    ```C
    static int num = 20;
    ```

        ```C
    int num = 20;
    ```

    另外我們再創立另外一個檔案將這個變數印出來

    ```C
    #include <stdio.h>
    
    int main()
    {
        extern int num;
        printf("%d\n", num);
        
        return 0;
    }

    /**************************
    /usr/bin/ld: /tmp/ccsqWDHO.o: in function `main':
    Embedded_system_0x10_issues_0x06_3.c:(.text+0xa): undefined reference to `num'
    collect2: error: ld returned 1 exit status
    **************************/
    ```

3. static 修飾一個函數，則這個函數的只能在本檔中調用，不能被其他檔調用。

    首先我們宣告一個header檔和C檔，來宣告了一個函數 func() ，並回傳數值10

    ```C
    int func();
    ```

    ```C
    #include "Embedded_system_0x10_issues_0x06_4.h"

    int func()
    {
        return 10;
    }
    ```

    接著我們再宣告一個檔案印出來這個函數的回傳值

    ```C
    #include <stdio.h>
    #include "Embedded_system_0x10_issues_0x06_4.h"

    int func();

    int main()
    {
        printf("%d\n", func());
        return 0;
    }

    /***********************************
    10
    ***********************************/
    ```

    改成static function

    ```C
    #include "Embedded_system_0x10_issues_0x06_4.h"

    static int func()
    {
        return 10;
    }
    ```

    那就會得到找不到函數的結果

    ```C
    #include <stdio.h>
    #include "Embedded_system_0x10_issues_0x06_4.h"

    int func();

    int main()
    {
        printf("%d\n", func());
        return 0;
    }

    /***********************************
    /usr/bin/ld: /tmp/ccNTcXus.o: in function `main':
    Embedded_system_0x10_issues_0x06_5.c:(.text+0xe): undefined reference to `func'
    collect2: error: ld returned 1 exit status
    ***********************************/
    ```

<h1 id="7">(7) Const的用法</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-7-const%E7%9A%84%E7%94%A8%E6%B3%95-30414b4d43e7)

## 原文翻譯

7. *What does the keyword const mean?*

> Keyword const代表什麼?

As soon as the interviewee says ‘const means constant’, I know I’m dealing with an amateur. Dan Saks has exhaustively covered const in the last year, such that every reader of ESP should be extremely familiar with what const can and cannot do for you. If you haven’t been reading that column, suffice it to say that const means “read-only”. Although this answer doesn’t really do the subject justice, I’d accept it as a correct answer. (If you want the detailed answer, then read Saks’ columns — carefully!).
> 當應試者回答說 ‘const就是常數’，我知道我會認為他們是業餘的。Dan Saks去年已經辛苦的概括const，因此每一個ESP(Embedded System Programming)的讀者應該要很熟悉 const 對你而言可以做什麼以及不能做什麼。如果你還沒有讀到這個專欄，只要說 const 代表 “read-only” 就夠了。雖然這個答案並不是完全，但我接受它是一個正確的答案。(如果你想要知道更詳細的答案，那仔細的就去讀Saks的專欄)

- 測試以下項目：

1. `const int a;` & `int const a;`

The first two mean the same thing, namely a is a const (read-only) integer.
> 前兩個代表同一件事情，也就是說 a 是個 const (read-only) 整數。

2. `const int *a;`

The third means a is a pointer to a const integer (i.e., the integer isn’t modifiable, but the pointer is).
> 第三個代表 a 是個指向 const int 的指標(意即，整數無法修改，但是指標可以)。

3. `int * const a;`

The fourth declares a to be a const pointer to an integer (i.e., the integer pointed to by a is modifiable, but the pointer is not).
> 第四個宣告 a 是個指向整數的 const 指標(意即，被指到的整數可以修改，但是指標沒辦法)。

4. `int const * a const;`

The final declaration declares a to be a const pointer to a const integer (i.e., neither the integer pointed to by a, nor the pointer itself may be modified).
> 最後一個宣告 a 是代表 const 指標指到 const integer(意即，被 a 指到的整數，或者是指標本身都無法修改)

- Incidentally, one might wonder why I put so much emphasis on const, since it is very easy to write a correctly functioning program without ever using it. There are several reasons:
> 附帶一提，你可能會好奇為什麼我會放這麼多強調在 const ，畢竟即使不用這個，也還是可以很容易的寫出正確功能的函數。主要有以下幾個原因

(a) The use of const conveys some very useful information to someone reading your code. In effect, declaring a parameter const tells the user about its intended usage. If you spend a lot of time cleaning up the mess left by other people, then you’ll quickly learn to appreciate this extra piece of information. (Of course, programmers that use const, rarely leave a mess for others to clean up…)
> 使用 const 概括一些非常有用的資訊對那些正在讀你程式的人。實際上，宣告一個 parameter const 會告訴使用者關於它的預期使用。如果你付了很多時間在清理其他人留下的混亂，你將會更快的學到感謝這個多餘的訊息。(當然，程式設計師使用 const ，很少會留下混亂給其他人清理)

(b) const has the potential for generating tighter code by giving the optimizer some additional information.
> Const有潛力產生更緊湊的程式碼藉由給予優化器一些附加資訊

(c) Code that uses const liberally is inherently protected by the compiler against inadvertent coding constructs that result in parameters being changed that should not be. In short, they tend to have fewer bugs.
> 使用 const 的程式碼自然的是固有的被編譯器保護來對抗不注意的程式結構導致不該改變的參數被改變。簡而言之，它們傾向擁有更少的bug

## 自我實作以及理解

1. `const int a;`

    ```C
    #include <stdio.h>

    int main()
    {
        const int a = 0;;
        a = 20;
        printf("%d\n", a);

        return 0;
    }

    /***************************************
    Embedded_system_0x10_issues_0x07_1.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_1.c:6:7: error: assignment of read-only variable ‘a’
        6 |     a = 20;
        |       ^
    ***************************************/
    ```

    可以發現無法改變變數 a 的數值

2. `int const a;`

    ```C
    #include <stdio.h>

    int main()
    {
        int const a = 0;;
        a = 20;
        printf("%d\n", a);

        return 0;
    }

    /****************************************
    Embedded_system_0x10_issues_0x07_2.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_2.c:6:7: error: assignment of read-only variable ‘a’
        6 |     a = 20;
        |       ^
    ****************************************/
    ```

    可以發現無法改變變數 a 的數值

3. `const int *a;`

    這裡我們宣告一個 const int *a，另外宣告一個 int b = 7，讓 *a 指向 b，接著再更改 *a 的數值，我們會發現編譯結果是過不了的，因為這裡是個指向 const int 的指標

    ```C
    #include <stdio.h>

    int main()
    {
        const int *a;
        int b = 7;
        a = &b;

        *a = 8;

        printf("%d\n", *a);

        return 0;
    }

    /***********************************
    Embedded_system_0x10_issues_0x07_3.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_3.c:9:8: error: assignment of read-only location ‘*a’
        9 |     *a = 8;
        |       
    ***********************************/
    ```

    但是我們可以更改指到的變數，下方的程式碼，我們一開始讓 *a 指到 b，印出 b 的數值，接著我們可以讓 *a 指到 c，並印出 c 的數值

    ```C
    #include <stdio.h>

    int main()
    {
        const int *a;
        int b = 7;
        a = &b;

        printf("%d\n", *a);

        int c = 8;
        a = &c;
        
        printf("%d\n", *a);

        return 0;
    }

    /*****************************
    7
    8
    *****************************/
    ```

4. `int * const a;`

    首先我們讓 *const a 一開始就指到 b，這時我們先印出 b 的數值，接著我們再讓 *a 的數值改變成 8，都可以順利修改

    ```C
    #include <stdio.h>

    int main()
    {
        int b = 7;
        int * const a = &b;

        printf("Before modification: %d\n", *a);

        *a = 8;

        printf("After modification: %d\n", *a);

        return 0;
    }

    /**************************************
    Before modification: 7
    Before modification: 8
    **************************************/
    ```

    那麼如果我們讓 *const a 指到其他的變數呢?，編譯結果是不通過的

    ```C
    #include <stdio.h>

    int main()
    {
        int b = 7;
        int * const a = &b;

        printf("%d\n", *a);

        int c = 8;
        a = &c;
        
        printf("%d\n", *a);

        return 0;
    }

    /************************************
    Embedded_system_0x10_issues_0x07_4_2.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_4_2.c:10:7: error: assignment of read-only variable ‘a’
    10 |     a = &c;
        |       ^
    ************************************/
    ```

5. `int const * a const;`

    首先我們宣告一個變數 b = 7，然後讓 const int* const a 指到這個變數並印出

    ```C
    #include <stdio.h>

    int main()
    {
        int b = 7;
        const int* const a = &b;
        
        printf("%d\n", *a);

        return 0;
    }

    /*************************************
    7
    *************************************/
    ```

    接著我們嘗試更改 *a 的數值為 8 ---> 編譯結果為不能修改

    ```C
    #include <stdio.h>

    int main()
    {
        int b = 7;
        const int* const a = &b;

        *a = 8;
        
        printf("%d\n", *a);

        return 0;
    }

    /************************************
    Embedded_system_0x10_issues_0x07_5_2.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_5_2.c:8:8: error: assignment of read-only location ‘*a’
        8 |     *a = 8;
        |        ^
    ************************************/
    ```

    接著我們再嘗試更改 *a 所指到的變數 ---> 編譯結果為不能修改

    ```C
    #include <stdio.h>

    int main()
    {
        int b = 7;
        const int* const a = &b;

        int c = 8;

        a = &c;
        
        printf("%d\n", *a);

        return 0;
    }

    /**************************************
    Embedded_system_0x10_issues_0x07_5_3.c: In function ‘main’:
    Embedded_system_0x10_issues_0x07_5_3.c:10:7: error: assignment of read-only variable ‘a’
    10 |     a = &c;
        |       ^
    **************************************/
    ```

<h1 id="8">(8) Volatile的用法</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-8-volatile%E7%9A%84%E7%94%A8%E6%B3%95-e9238cfd38ff)

## 原文翻譯

8. *What does the keyword volatile mean? Give three different examples of its use.*
> Keyword volatile代表什麼? 給出三個它的使用的不同範例

A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. In particular, the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. Examples of volatile variables are:
> 一個 volatile 變數會被不可預期的改變。因此，編譯器可以使這個變數沒有假設。具體來說，編譯器會小心的重載這個變數當這個變數每次被使用時，而不是保存一份拷貝在編譯器中。Volatile變數的範例如下:

(a) Hardware registers in peripherals (e.g., status registers)
> 周邊設備的硬體暫存器 (如: 狀態暫存器)

(b) Non-stack variables referenced within an interrupt service routine.
> 中斷程式routine會訪問到的 Non-statck 變數

(c) Variables shared by multiple tasks in a multi-threaded application.
> 多執行緒應用中多個任務共享的變數

If a candidate does not know the answer to this question, they aren’t hired. I consider this the most fundamental question that distinguishes between a Non-automatic variables and an ‘embedded systems programmer’. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster.
> 如果面試者不知道如何回答這個問題，他們不會被聘僱。我認為這是個基礎的問題可以來區分一個C語言程式設計師以及一個嵌入式系統程式設計師。嵌入式人員時常要處理硬體、中斷、RTOSes之類的問題。這些都需要volatile變數。不懂volatile概念的話會導致災難。

On the (dubious) assumption that the interviewee gets this question correct, I like to probe a little deeper, to see if they really understand the full significance of volatile. In particular, I’ll ask them the following:
> 假設這些應試者真的答對了這題(半信半疑的)，我會探查更深一點，來看他們是否真的完全理解 volatile 的重要性。具體來說，我會問他們以下這些問題

1. Can a parameter be both const and volatile? Explain your answer.
> 一個 parameter 是否可以同時為 const 也可以為 volatile? 解釋你的答案

Yes. An example is a read only status register. It is volatile because it can change unexpectedly. It is const because the program should not attempt to modify it.
> 是的。一個範例是一個唯讀的 status register。它是 volatile 因為它可以不可預期的改變。它是 const 因為程式不應該企圖改變它。

2. Can a pointer be volatile? Explain your answer.
> 指標可以是 volatile? 解釋你的答案

Yes. Although this is not very common. An example is when an interrupt service routine modifies a pointer to a buffer.
> 是的。雖然這並不普遍。一個例子是中斷服務routine改變一個指向 buffer 的指標

3. What is wrong with the following function?:
> 下面這個函數有什麼問題?

```C
int square(volatile int *ptr)
{
return *ptr * *ptr;
}
```

This one is wicked. The intent of the code is to return the square of the value pointed to by *ptr. However, since *ptr points to a volatile parameter, the compiler will generate code that looks something like this:
> 這個是很壞的。這個程式的意圖是為了回傳被 *ptr 指到的數的平方。然而，因為 *ptr 指到的是 volatile parameter，編譯器會產生看起來像是以下的程式碼

```C
int square(volatile int *ptr)
{
int a,b;
a = *ptr;
b = *ptr;
return a * b;
}
```

因為 *ptr 有可能不可預期的改變，很有可能 a 與 b 會是不同的。所以，這個程式碼可能會回傳布是平方的數值。正確寫法的程式碼應該要像是:

```C
long square(volatile int *ptr)
{
int a;
a = *ptr;
return a * a;
}
```

<h1 id="9">(9) Bit操作</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-9-bit%E6%93%8D%E4%BD%9C-f119a38eeba6)

## 原文翻譯

9. *Embedded systems always require the user to manipulate bits in registers or variables. Given an integer variable a, write two code fragments. The first should set bit 3 of a. The second should clear bit 3 of a. In both cases, the remaining bits should be unmodified.*
> 嵌入式系統總是需要使用者去操作在暫存器或者變數中的位元。給一個整數變數 a ，寫出兩個程式片段。第一個要去設定 a 的 bit 3。第二個要去清除 a 的bit 3。在這兩個案例中，其他的位元不應該被改動到

Use #defines and bit masks. This is a highly portable method, and is the one that should be used. My optimal solution to this problem would be:
> 使用 #defines與bit masks。這是個高度可移植的方法，而且也是個該使用的方法。我對這題的最佳解是:

```C
#define BIT3 (0x1 << 3)

static int a;

void set_bit3(void) {
    a |= BIT3;
}

void clear_bit3(void) {
    a &= ~BIT3;
}
```

## 自我實作以及理解

- 位元操作是嵌入式系統很基本的操作也是面試的常問考題之一

- 基本上我對位元操作的理解，大都來自以下這篇stack overflow的文章，我也會主要使用這篇文章做講解

    [How do you set, clear, and toggle a single bit?](https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit)

1. Set Bit

    假定我們現在有一個變數 a 為 0，我們要設定第3的位元為1，那這個時候，我們就讓它 |= (1 << 3)，也就是說去 |= 1向左位移 3 個位元的數，也就是說 a 這個數值要去 | 100這個數，就是下方這個結果

    `000 | 100 = 100 `

    ```C
    #include <stdio.h>

    int main()
    {
        int a = 0;

        a |= (1 << 3);

        printf("%d\n", a);
        
        return 0;
    }

    /******************************
    8
    ******************************/
    ```

    總而言之，就是以下的程式碼(n為設定位元)

    `a |= (1 << n)`

2. Clear Bit

    那假設我們現在設定了第三個位元，如果現在我們想要清掉第三個位元的話，我們該如何實作，這裡int是32位元，這裡我們只呈現一開始的8位元，來簡化說明，a 現在的二進位是00000100，我們如果讓一個 1的數值，同樣也向左位移 3 位元，也就是 00000100，然後這時候反轉，則數值會變為11111011，這時候再 & 起來，則就可以清除掉第 3 個位元

    ```C
    #include <stdio.h>

    int main()
    {
        int a = 0;

        a |= (1 << 3);

        printf("Set bit 3: %d\n", a);

        a &= ~(1 << 3);
        
        printf("Clear bit 3: %d\n", a);

        
        return 0;
    }

    /**********************************
    Set bit 3: 8
    Clear bit 3: 0
    **********************************/
    ```

    總而言之，就是以下的程式碼(n為設定位元)

    `a &= ~(1 << n)`

3. Toggle Bit

    如果我們要一次set bit，一次clear bit，那麼我們可以使用toggle bit的方式。可以使用 xor 運算子。

    當我們數值為0的時候，這時候我們第一次toggle，這時候就會變成，記住相同為0，相異為1，所以這時候數值就會變為 8

    `000 ^ 100 = 100`

    當我們再toggle一次，記住相同為0，相異為1，這時候就又會變成

    `100 ^ 100 = 000`

    ```C
    #include <stdio.h>

    int main()
    {
        int a = 0;

        a |= (1 << 3);

        printf("Set bit 3: %d\n", a);

        a &= ~(1 << 3);
        
        printf("Clear bit 3: %d\n", a);
        
        a ^= (1 << 3);

        printf("Toggle bit 3(first time): %d\n", a);
        
        a ^= (1 << 3);

        printf("Toggle bit 3(second time): %d\n", a);

        
        return 0;
    }

    /******************************************
    Set bit 3: 8
    Clear bit 3: 0
    Toggle bit 3(first time): 8
    Toggle bit 3(second time): 0
    ******************************************/
    ```

    總而言之，就是以下的程式碼(n為設定位元)

    `a ^= (1 << n)`

<h1 id="10">(10) 存取固定的記憶體位置</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-10-%E5%AD%98%E5%8F%96%E5%9B%BA%E5%AE%9A%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E4%BD%8D%E7%BD%AE-f48fc960e70c)

## 原文翻譯

10. *Embedded systems are often characterized by requiring the programmer to access a specific memory location. On a certain project it is required to set an integer variable at the absolute address 0x67a9 to the value 0xaa55. The compiler is a pure ANSI compiler. Write code to accomplish this task.*
> 嵌入式系統常有一個特點是要求程式設計失去存取特定的記憶體位置。在某個專案中被要求設定一個絕對位址在0x67a9的整數變數為數值0xaa55。編譯器是一個純ANSI編譯器。寫下程式碼來完成這個任務。

This problem tests whether you know that it is legal to typecast an integer to a pointer in order to access an absolute location. The exact syntax varies depending upon one’s style. However, I would typically be looking for something like this:
> 這個問題測試你是否知道這是合法的去型別轉換一個整數成一個指標為了存取一個絕對位置。確切的語法根據每個人的風格因人而異。然而，我典型的找像是這個:

```C
int *ptr;

ptr = (int *)0x67a9;

*ptr = 0xaa55;
```

A more obfuscated approach is:
> 一個更混淆的方法是:

```C
*(int * const)(0x67a9) = 0xaa55;
```

Even if your taste runs more to the second solution, I suggest the first solution when you are in an interview situation.
> 即使你的品味更偏向第二種方案，我建議第一個方案當你在面試的時候

<h1 id="11">(11) 中斷</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-11-%E4%B8%AD%E6%96%B7-7c59ac7a10c4)

## 原文翻譯

11. *Interrupts are an important part of embedded systems. Consequently, many compiler vendors offer an extension to standard C to support interrupts. Typically, this new key word is `__interrupt`. The following code uses `__interrupt` to define an interrupt service routine. Comment on the code.*
> 中斷是嵌入式系統很重要的一部分。因此，很多編譯器供應商提供一個標準C的擴展來支持中斷。典型的，這個新的key word是__interrupt。以下的程式碼使用__interrupt來定義一個中斷service routine。評論這個程式碼

```C
__interrupt double compute_area(double radius) {

double area = PI * radius * radius;

printf(“nArea = %f”, area);

return area;
}
```

This function has so much wrong with it, it’s almost tough to know where to start.
> 這個函數有很多錯誤在裡面，幾乎很難知道要從哪邊開始

(a) Interrupt service routines cannot return a value. If you don’t understand this, then you aren’t hired.
> 中斷service routines無法回傳數值。如果你不知道這個，你無法被聘僱。

(b) ISR’s cannot be passed parameters. See item (a) for your employment prospects if you missed this.
> ISR無法傳遞參數。如果你錯過了這個，你的聘僱期望會跟(a)一樣

(c) On many processors / compilers, floating point operations are not necessarily re-entrant. In some cases one needs to stack additional registers, in other cases, one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating point math here.
> 在很多處理器/編譯器，浮點數操作是不必要可重入的。在一些案例中需要堆積額外的暫存器，在其他案例中，就簡單的不能在ISR中做浮點數。而且，在這裡一個人不知道關於做浮點數數學的智慧，鑒於一個通用的經驗法則來說，ISR應該要是短而甜的，

[可重入函數 程式設計規範](https://b8807053.pixnet.net/blog/post/3612409)

[可重入的 維基百科](https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5)

(d) In a similar vein to point (c), printf() often has problems with reentrancy and performance. If you missed points (c)& (d) then I wouldn’t be too hard on you. Needless to say, if you got these two points, then your employment prospects are looking better and better.
> 從(c)一脈相承過來，printf()通常在可重入與效能有問題。如果你錯過了(c)與(d)的點，那我不會太為難你。另外不用多說，如果你得到了這兩點，那麼你獲得聘僱的預期將越來越高

<h1 id="12">(12) 整型提升的問題</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-12-%E7%A8%8B%E5%BC%8F%E7%AF%84%E4%BE%8B-b1fdb1cf7e2b)

## 原文翻譯

12. *What does the following code output and why?*
> 你認為下方的程式碼將會輸出什麼並且為什麼會這樣輸出?

```C
void foo(void)
{
    unsigned int a = 6;
    int b = -20;

    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
```

This question tests whether you understand the integer promotion rules in C — an area that I find is very poorly understood by many developers. Anyway, the answer is that this outputs “> 6”. The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Thus –20 becomes a very large positive integer and the expression evaluates to greater than 6. This is a very important point in embedded systems where unsigned data types should be used frequently (see reference 2). If you get this one wrong, then you are perilously close to not being hired.
> 這個問題測試你是否了C語言的解整型提升規則 — 一個我發覺很多開發者都不太了解的領域。不管怎樣，這個答案會輸出“> 6”。這個原因是因為這個有著singed與unsinged型態的表達式所有的運算元被提升為unsigned型態。因此–20變成了一個非常大的正整數並且這個表達式計算出大於6。這是個在嵌入式系統非常重要的點因為unsigned的資料型態應該會被頻繁的使用(看參考2)。如果你答錯了這一題，那麼你已經危險的靠近無法聘僱的邊緣。

## 自我實作以及理解

這裡我們直接照著原文來看結果會是怎樣，是否都被提升為unsigned int

---> 輸出結果真 > 6，所以確實都被提升為正整數

```C
#include <stdio.h>

int main()
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");

    return 0;
}

/*******************************************
> 6
*******************************************/
```

我們再多測一個項目，這裡我們將a改為整數，設成20，將b改成unsigned int，設成-30

---> 輸出結果為 > 20，代表確實都被設為正整數

```C
#include <stdio.h>

int main()
{
    int a = 20;
    unsigned int b = -30;
    (a+b > 20) ? puts("> 20") : puts("<= 20");

    return 0;
}

/*******************************************
> 20
*******************************************/
```

<h1 id="13">(13) 0的一補數</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-13-0%E7%9A%84%E4%B8%80%E8%A3%9C%E6%95%B8-4362a9c81423)

## 原文翻譯

13. *Comment on the following code fragment?*
> 評論以下的程式碼片段?

```C
unsigned int zero = 0;
unsigned int compzero = 0xFFFF; /*1’s complement of zero */
```

On machines where an int is not 16 bits, this will be incorrect. It should be coded:
> 當一個機器不是16位元的，這個會導致錯誤。它應該被寫成這樣:

```C
unsigned int compzero = ~0;
```

This question really gets to whether the candidate understands the importance of word length on a computer. In my experience, good embedded programmers are critically aware of the underlying hardware and its limitations, whereas computer programmers tend to dismiss the hardware as a necessary annoyance.
> 這個問題真的可以知道應試者是否了解字組長度在電腦的重要性。在我的經驗中，好的嵌入式程式設計師會嚴謹的知道硬體的細節與它的限制，然後電腦程式設計師傾向忽視硬體並把它視為一個必要的煩擾。

By this stage, candidates are either completely demoralized — or they are on a roll and having a good time. If it is obvious that the candidate isn’t very good, then the test is terminated at this point. However, if the candidate is doing well, then I throw in these supplemental questions. These questions are hard, and I expect that only the very best candidates will do well on them. In posing these questions, I’m looking more at the way the candidate tackles the problems, rather than the answers. Anyway, have fun…
> 到了這個階段，應試者會完全的沮喪我或者是連連獲勝以及有個好時光。如果明顯的應試者不是非常好，那麼這個測驗將在這裡結束。然而，如果應試者做得好，那麼我將丟出這些追加的問題。這些問題算難，而且我預期只有非常好的應試者會做好它們。提出這些問題後，我更側重的是應試者處理這些問題，而不是答案。不管怎樣，玩得開心…

## 自我實作以及理解

原文中compzero被設為0xFFFF，但是事實上機器有可能不是16位元

`unsigned int compzero = 0xFFFF;`

```C
#include <stdio.h>

int main()
{
    unsigned int zero = 0;
    unsigned int compzero = 0xFFFF;
    unsigned int compzero_with_tilde = ~0;

    printf("copmzero: %x\n", compzero);
    printf("compzero_with_tilde: %x\n", compzero_with_tilde);

    return 0;
}

/*****************************************
copmzero: ffff
compzero_with_tilde: ffffffff
*****************************************/
```

輸出結果我們可以看到在Ubuntu 64位元的系統上，我們可以發現0的一補數其實是0xffffffff，而不是0xfffff，所以要得到正確的一補數，用`~0`是個安全的做法

<h1 id="14">(14) 動態記憶體配置</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-14-%E5%8B%95%E6%85%8B%E8%A8%98%E6%86%B6%E9%AB%94%E9%85%8D%E7%BD%AE-d974130fae2f)

## 原文翻譯

14. *Although not as common as in non-embedded computers, embedded systems still do dynamically allocate memory from the heap. What are the problems with dynamic memory allocation in embedded systems?*
> 雖然在非嵌入式系統上並不常見，嵌入式系統仍然在heap上做動態的配置記憶體。做動態記憶體配置在嵌入式系統上會有什麼問題?

Here, I expect the user to mention memory fragmentation, problems with garbage collection, variable execution time, etc. This topic has been covered extensively in ESP, mainly by Plauger. His explanations are far more insightful than anything I could offer here, so go and read those back issues! Having lulled the candidate into a sense of false security, I then offer up this tidbit:
> 這裡，我預期使用者描述到記憶體碎片，垃圾回收的問題，變數的執行時間等。這些議題已經被Plauger在ESP雜誌上廣泛的涉及。他的解釋遠是更深刻見解的遠超任何我在這裡可以提供的，所以去並且讀這些議題。緩和應試者進入一個虛假安全的感覺後，接著我會提供這個小題目

What does the following code fragment output and why?
> 以下的程式片段輸出是什麼並且為什麼這樣輸出?

```C
char *ptr;

if ((ptr = (char *)malloc(0)) == NULL) {
    puts(“Got a null pointer”);
}
else {
    puts(“Got a valid pointer”);
}
```

This is a fun question. I stumbled across this only recently, when a colleague of mine inadvertently passed a value of 0 to malloc, and got back a valid pointer! After doing some digging, I discovered that the result of malloc(0) is implementation defined, so that the correct answer is ‘it depends’. I use this to start a discussion on what the interviewee thinks is the correct thing for malloc to do. Getting the right answer here is nowhere near as important as the way you approach the problem and the rationale for your decision.
> 這是個有趣的問題。我在最近偶然發現，當一個我的同事不慎的傳入0的數值進入malloc，然後得到一個有效的指標!在做了一些挖掘之後，我發現這個malloc(0)的結果是實作定義的，所以正確的答案是"要看情況"。我使用這個來開啟一個討論來看應試者怎麼思考malloc所做的正確的事情。這裡得到正確的答案並不比你靠近這個問題以及你決定的原理闡述重要。

## 自我實作以及理解

我們照著原文刻出以下的程式碼

---> 輸出結果為確實可以拿到有效的指標

```C
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char *ptr;
    if ((ptr = (char *)malloc(0)) == NULL) {
        puts("Got a null pointer");
    }
    else {
        puts("Got a valid pointer");
    }
}

/******************************************
Got a valid pointer
******************************************/
```

Note：[What's the point of malloc(0)?](https://stackoverflow.com/questions/2022335/whats-the-point-of-malloc0)

<h1 id="15">(15) Typedef</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-15-typedef-76151c5b9ec3)

## 原文翻譯

15. *Typedef is frequently used in C to declare synonyms for pre-existing data types. It is also possible to use the preprocessor to do something similar. For instance, consider the following code fragment:*
> Typedef 頻繁的在C語言中使用來對之前存在的資料型態宣告為同義詞。這也是有可能的使用預處理器來做相似的事情。舉例來說，考慮下方的程式碼片段:

```C
#define dPS struct s *

typedef struct s * tPS;
```

The intent in both cases is to define dPS and tPS to be pointers to structure s. Which method (if any) is preferred and why?
> 在這兩個案例的目的是去定義 dPS 與 tPS來當指向結構 s 的指標。哪個方法(如果有的話) 是比較偏向的並且解釋為什麼?

This is a very subtle question, and anyone that gets it right (for the right reason) is to be congratulated or condemned (“get a life“ springs to mind). The answer is the typedef is preferred. Consider the declarations:
> 這是一個非常微妙的問題，而且任何答對這題的人(要有正確的理由)是可以被恭喜或者是譴責(“找點有意思的事“浮現在腦中)。這個答案是 typedef 是比較好的。 思考下面的宣告:

```C
dPS p1,p2;

tPS p3,p4;
```

第一個會被擴展成 `struct s * p1, p2;`

which defines p1 to be a pointer to the structure and p2 to be an actual structure, which is probably not what you wanted.

> 定義 p1 會變成指向結構的指標而 p2 會變成一個真正的結構，變成可能不是你想要的。

The second example correctly defines p3 & p4 to be pointers.
> 第二個範例正確的定義 p3 & p4 成為指標

## 自我實作以及理解

我們來做第一個測試，我們讓p1與p2分別指向 s_data，`p1 = &s_data; p2 = &s_data;`，然後編譯

```C
#include <stdio.h>

struct s
{
    int a;
};

#define dPS struct s *

typedef struct s * tPS;

int main()
{
    struct s s_data;
    s_data.a = 5; 
    
    dPS p1,p2;
    tPS p3,p4;

    p1 = &s_data;
    p2 = &s_data;

    return 0;
}

/********************************
Embedded_system_0x10_issues_0x0f_1.c: In function ‘main’:
Embedded_system_0x10_issues_0x0f_1.c:21:10: error: incompatible types when assigning to type ‘struct s’ from type ‘struct s *’
   21 |     p2 = &s_data;
      |          ^
********************************/
```

看來 p2 不是指標，接著我們對p2的成員a給予值，然後印出p1的a數值與p2的a數值

```C
#include <stdio.h>

struct s
{
    int a;
};

#define dPS struct s *

typedef struct s * tPS;

int main()
{
    struct s s_data;
    s_data.a = 5; 
    
    dPS p1,p2;
    tPS p3,p4;

    p1 = &s_data;
    
    p2.a = 10;

    printf("Value of a in p1: %d\n", p1->a);
    printf("Value of a in p2: %d\n", p2.a);


    return 0;
}

/*********************************************
Value of a in p1: 5
Value of a in p2: 10
**********************************************/
```

我們就可以發現輸出結果為p1的成員a為5，p2的成員a為10。所以當我們宣告成: dPS p1,p2，會如原文所說的擴展成這樣 struct s * p1, p2;，p1還是指標，而p2是一個結構變數

接著我們將 p3 與 p4 指向s_data，發現都能指成功

```C
#include <stdio.h>

struct s
{
    int a;
};

#define dPS struct s *

typedef struct s * tPS;

int main()
{
    struct s s_data;
    s_data.a = 5; 
    
    dPS p1,p2;
    tPS p3,p4;

    p1 = &s_data;
    
    p2.a = 10;

    printf("Value of a in p1: %d\n", p1->a);
    printf("Value of a in p2: %d\n", p2.a);

    p3 = &s_data;

    p4 = &s_data;

    printf("Value of a in p3: %d\n", p3->a);
    printf("Value of a in p4: %d\n", p4->a);


    return 0;
}

/***********************************************
Value of a in p1: 5
Value of a in p2: 10
Value of a in p3: 5
Value of a in p4: 5
***********************************************/
```

接著我們將p3與p4的成員a也都印出來，會發現都是5，tPS p3,p4;這樣宣告確實可以讓p3與p4都是指標

<h1 id="16">(16) a++的問題</h1>

[Medium](https://medium.com/@racktar7743/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E7%9F%A5%E9%81%93%E7%9A%840x10%E5%80%8B%E5%95%8F%E9%A1%8C-16-a-%E7%9A%84%E5%95%8F%E9%A1%8C-867b66cdc9e1)

16. *C allows some appalling constructs. Is this construct legal, and if so what does this code do?*
> C語言允許一些可怕的結構。這個結構合法嗎? 如果合法的話這段程式碼會做什麼?

```C
int a = 5, b = 7, c;

c = a+++b;

/*******************************
a = 6, b = 7 & c = 12;
*******************************/
```

This question is intended to be a lighthearted end to the quiz, as, believe it or not, this is perfectly legal syntax. The question is how does the compiler treat it? Those poor compiler writers actually debated this issue, and came up with the “maximum munch” rule, which stipulates that the compiler should bite off as big a (legal) chunk as it can. Hence, this code is treated as:
> 這個問題是為這個測驗的一個愉快的結束。不管你相信或不相信，這是個完全的合法語法。這個問題是編譯器如何處理它? 那些不好的編譯器作者實際上爭論這個問題。根據 “maximum munch”規則，明確說明編譯器應該要盡可能地咬掉最大的一個(合法個)chunk。因此，這個程式碼要被處理為:

If you knew the answer, or guessed correctly — then well done. If you didn’t know the answer then I would not consider this to be a problem. I find the biggest benefit of this question is that it is very good for stimulating questions on coding styles, the value of code reviews and the benefits of using lint.
> 如果你知道這個答案，或者是猜對 — 那做得好。如果你不知道這個答案那麼我不會認為這是一個問題。我發現這個問題的最大益處是這是個非常好的激勵問題在於程式風格，程式碼審查的價值以及使用lint的益處。

[代码的 Lint 是什么意思](https://segmentfault.com/a/1190000040009402)

## 自我實作以及理解

這裡我們照著原文宣告a = 6，b = 7，接著讓 c = a+++b。

```C
#include <stdio.h>

int main()
{
    int a = 5, b = 7, c;
    c = a+++b;

    printf("a: %d, b: %d, c: %d\n", a, b, c);

    return 0;
}

/***********************************************
a: 6, b: 7, c: 12
***********************************************/
```

這裡實際上 a會先與b相加，所以是5+7=12，c的數值是12，b的數值不會變是 7，a跟b加完之後，接著會a++，所以a變成6，其實a++就是後做，先運算完之後再++，所以才會5加完7之後，a自身才++變成6

- a++與++a

    ```C
    #include <stdio.h>

    int main()
    {
        int a = 5, b = 7, c;

        c = a++;

        printf("a: %d, b: %d, c: %d\n", a, b, c);
        
        c = ++b;
        
        printf("a: %d, b: %d, c: %d\n", a, b, c);

        return 0;
    }

    /******************************************
    a: 6, b: 7, c: 5
    a: 6, b: 8, c: 8
    ******************************************/
    ```
